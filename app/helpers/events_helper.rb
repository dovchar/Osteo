module EventsHelper

  # Returns an HTML string for the given date pair.
  #
  # See Time#format_datepair
  # See DateHelper#time_tag
  #
  # ==== Example
  #   datepair_tag @event.starts_at, @event.ends_at, @event.all_day
  #   # => 'Tue, January 31, 2:30pm &ndash; 3pm'
  #
  def datepair_tag(starts_at, ends_at, all_day)
    raw "#{Time.format_datepair(starts_at, ends_at, all_day)}"
  end
end

module ActionView
  module Helpers
    module FormHelper

      # Returns a set of tags to select a calendar event (date pair).
      #
      # Similar to two datetime_select but uses jquery-timepicker datepair.js.
      #
      # See https://github.com/jonthornton/jquery-timepicker
      # See DateHelper#datetime_select
      #
      # Creates several fields:
      # - start date text input field ("2011-11-28") using a datepicker
      # - start time text input field ("22:00") using a timepicker
      # - end time text input field ("23:00") using a timepicker
      # - end date text input field ("2011-11-28") using a datepicker
      # - all day check box
      #
      # ==== Example
      #   datepair_select @event.starts_at, @event.ends_at, @event.all_day
      #
      # Unobtrusive JavaScript: if disabled, the two text fields will still work.
      #
      # TODO Move to a gem
      def datepair_select(object_name, starts_at, ends_at, all_day)
        starts_at = starts_at.round(Event::STEP_MINUTE.minutes).in_time_zone(Event::TIME_ZONE)
        ends_at = ends_at.round(Event::STEP_MINUTE.minutes).in_time_zone(Event::TIME_ZONE)

        starts_at_date = text_field object_name, :starts_at_date, { value: starts_at.strftime(Event::DATE_FORMAT), class: "date start" }
        starts_at_time = text_field object_name, :starts_at_time, { value: starts_at.strftime(Event::TIME_FORMAT), class: "time start" }
        ends_at_time = text_field object_name, :ends_at_time, { value: ends_at.strftime(Event::TIME_FORMAT), class: "time end" }
        ends_at_date = text_field object_name, :ends_at_date, { value: ends_at.strftime(Event::DATE_FORMAT), class: "date end" }

        all_day_check_box = check_box object_name, :all_day
        all_day_label = label object_name, :all_day

        hide_js = javascript_tag "
          $(document).ready(function() {
            all_day = $('##{field_id object_name, :all_day}');
            all_day.change(function() {
              starts_at_time = $('##{field_id object_name, :starts_at, 'time'}');
              ends_at_time = $('##{field_id object_name, :ends_at, 'time'}');
              if (all_day.prop('checked')) {
                starts_at_time.hide();
                ends_at_time.hide();
              } else {
                starts_at_time.show();
                ends_at_time.show();
              }
            });
          });"

        return starts_at_date + starts_at_time + 'to' + ends_at_time + ends_at_date +
               all_day_check_box + all_day_label + hide_js
      end

      private

      def field_id(object_name, method, label = nil)
        if label
          "#{object_name}_#{method}_#{label}"
        else
          "#{object_name}_#{method}"
        end
      end
    end
  end
end

class ActionView::Helpers::FormBuilder
  def datepair_select(starts_at, ends_at, all_day)
    @template.datepair_select(@object_name, starts_at, ends_at, all_day)
  end
end

# TODO Should be moved somewhere else
class Time

  # Parses the params generated by datepair_select helper.
  #
  # datepair_select returns two fields #{my_field}_date and #{my_field}_time
  # instead of serializing params into a DateTime object directly as would do
  # the standard Rails datetime helper. I don't know how to make it transparent :/
  #
  # Should be used inside the controller.
  #
  # ==== Example
  #   # View
  #   <%= form_for(@event) do |f| %>
  #     <%= f.datepair_select @event.starts_at, @event.ends_at, @event.all_day %>
  #   <% end %>
  #
  #   # Controller
  #   class EventController < ApplicationController
  #     def create
  #       Time.parse_datepair_select(params, :event, :starts_at)
  #       Time.parse_datepair_select(params, :event, :ends_at)
  #       @event = Event.new(params[:event])
  #       # [...]
  #     end
  #   end
  #
  def self.parse_datepair_select(params, model, field)
    date = params["#{model}"]["#{field}_date"]
    time = params["#{model}"]["#{field}_time"]

    begin
      str = date + ' ' + time
      params["#{model}"]["#{field}"] = Time.parse(str)
    rescue
      # Variables date and time can be nil in case JavaScript
      # is not used (for example when running the unit tests)

      # Variables date and time can contain unparseable text,
      # Time.parse will then fail
    end

    params["#{model}"].delete("#{field}_date")
    params["#{model}"].delete("#{field}_time")
  end

  # Rounds the time.
  #
  # ==== Examples
  #   Time.new(2011, 11, 13, 03, 51, 00).round(10.minutes) # => 2011-11-13 03:50:00
  #   Time.new(2011, 11, 13, 13, 42, 24).round()           # => 2011-11-13 13:42:00
  #   Time.new(2011, 11, 13, 13, 42, 24).round(1.hour)     # => 2011-11-13 14:00:00
  #
  def round(seconds = 60)
    Time.zone.at((self.to_f / seconds).round * seconds)
  end

  # Formats a calendar event (date pair) in a human friendly way.
  #
  # Follows the same rules as in Google Calendar.
  #
  # ==== Example
  #   Time.format_datepair(
  #     Time.new(2012, 01, 31, 14, 30),
  #     Time.new(2012, 01, 31, 15, 00)
  #   ) # => Tue, January 31, 2:30pm - 3pm
  #
  # See unit tests for more examples.
  #
  # +all_day+:: can be a boolean or the symbol :all_day
  def self.format_datepair(starts_at, ends_at, all_day = false)
    # See strftime reference and sandbox http://strfti.me/
    # %a, %B %d, %Y           => Tue, January 31, 2012
    # %a, %B %d               => Tue, January 31
    # %a, %B %d, %-l:%M%P     => Tue, January 31, 11:59am
    # %a, %B %d, %-l%P        => Tue, January 31, 1pm
    # %a, %B %d, %Y, %-l:%M%P => Tue, January 31, 2012, 11:59am
    # %-l%P                   =>  1pm

    # Converts to local time
    starts_at = starts_at.in_time_zone(Event::TIME_ZONE) unless starts_at.nil?
    ends_at = ends_at.in_time_zone(Event::TIME_ZONE) unless ends_at.nil?
    str = ''

    # "The en dash is commonly used to indicate a closed range of values
    # [...] such as those between dates, times, or numbers"
    # See http://en.wikipedia.org/wiki/Dash#En_dash
    range_separator = ' &ndash; '

    this_year = Time.now.year

    ends_at = starts_at if ends_at.nil?

    if starts_at.year == this_year && ends_at.year == this_year
      # Don't print the year

      if starts_at.month == ends_at.month && starts_at.day == ends_at.day
        # Same day

        if all_day || all_day == :all_day
          # All day long, don't print the time
          # Tue, January 31
          str = starts_at.strftime('%a, %B %d')
        else
          # Print the time
          # Tue, January 31, 11:59am
          # Tue, January 31, 1pm

          if starts_at.min == 0
            # Tue, January 31, 1pm
            str = starts_at.strftime('%a, %B %d, %-l%P')
          else
            # Tue, January 31, 11:59am
            str = starts_at.strftime('%a, %B %d, %-l:%M%P')
          end
          str += range_separator
          if ends_at.min == 0
            str += ends_at.strftime('%-l%P')
          else
            str += ends_at.strftime('%-l:%M%P')
          end
        end

      else
        # Different days, print ends_at part

        if all_day || all_day == :all_day
          # All day long, don't print the time
          # Tue, January 31
          str = starts_at.strftime('%a, %B %d')
          str += range_separator
          str += ends_at.strftime('%a, %B %d')
        else
          # Print the time
          if starts_at.min == 0
            # Tue, January 31, 1pm
            str = starts_at.strftime('%a, %B %d, %-l%P')
          else
            # Tue, January 31, 11:59am
            str = starts_at.strftime('%a, %B %d, %-l:%M%P')
          end
          str += range_separator
          if ends_at.min == 0
            str += ends_at.strftime('%a, %B %d, %-l%P')
          else
            str += ends_at.strftime('%a, %B %d, %-l:%M%P')
          end
        end

      end
    else
      # Print the year

      if starts_at.month == ends_at.month && starts_at.day == ends_at.day
        # Same day

        if all_day || all_day == :all_day
          # All day long, don't print the time
          # Tue, January 31, 2012
          str = starts_at.strftime('%a, %B %d, %Y')
        else
          # Print the time
          if starts_at.min == 0
            # Tue, January 31, 2012, 1pm
            str = starts_at.strftime('%a, %B %d, %Y, %-l%P')
          else
            # Tue, January 31, 2012, 11:59am
            str = starts_at.strftime('%a, %B %d, %Y, %-l:%M%P')
          end
          str += range_separator
          if ends_at.min == 0
            str += ends_at.strftime('%-l%P')
          else
            str += ends_at.strftime('%-l:%M%P')
          end
        end

      else
        # Different days

        if all_day || all_day == :all_day
          # All day long, don't print the time
          # Tue, January 31, 2012
          str = starts_at.strftime('%a, %B %d, %Y')
          str += range_separator
          if starts_at.year == ends_at.year
            str += ends_at.strftime('%a, %B %d')
          else
            str += ends_at.strftime('%a, %B %d, %Y')
          end
        else
          # Print the time
          if starts_at.min == 0
            # Tue, January 31, 2012, 1pm
            str = starts_at.strftime('%a, %B %d, %Y, %-l%P')
          else
            # Tue, January 31, 2012, 11:59am
            str = starts_at.strftime('%a, %B %d, %Y, %-l:%M%P')
          end
          str += range_separator
          if ends_at.min == 0
            if starts_at.year == ends_at.year
              str += ends_at.strftime('%a, %B %d, %-l%P')
            else
              str += ends_at.strftime('%a, %B %d, %Y, %-l%P')
            end
          else
            if starts_at.year == ends_at.year
              str += ends_at.strftime('%a, %B %d, %-l:%M%P')
            else
              str += ends_at.strftime('%a, %B %d, %Y, %-l:%M%P')
            end
          end
        end

      end
    end

    return str
  end

end
